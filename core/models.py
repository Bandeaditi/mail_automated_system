"""
Data models - Updated with urgency_score for content-based sorting
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, List


class Importance(Enum):
    """Email importance levels"""
    CRITICAL = 4
    HIGH = 3
    NORMAL = 2
    LOW = 1
    UNKNOWN = 0


class Replyability(Enum):
    """Whether an email should be replied to"""
    YES = "YES"
    NO = "NO"
    UNKNOWN = "UNKNOWN"


class Action(Enum):
    """Recommended action for the email"""
    REPLY = "REPLY"
    READ_ONLY = "READ_ONLY"
    TRACK = "TRACK"
    IGNORE = "IGNORE"
    UNKNOWN = "UNKNOWN"


@dataclass
class Email:
    """Represents a single email message"""
    uid: str
    from_address: str
    to_address: str
    subject: str
    body: str
    date: datetime
    message_id: Optional[str] = None
    in_reply_to: Optional[str] = None
    references: Optional[str] = None
    
    # Analysis results
    importance: Importance = Importance.UNKNOWN
    replyability: Replyability = Replyability.UNKNOWN
    action: Action = Action.UNKNOWN
    analysis_reasoning: Optional[str] = None
    
    # NEW: Content-based urgency score (0-100)
    urgency_score: int = 0
    
    # Reply draft
    draft_reply: Optional[str] = None
    
    def is_noreply(self) -> bool:
        """Check if email is from a no-reply address"""
        noreply_patterns = ['noreply', 'no-reply', 'donotreply', 'do-not-reply']
        email_lower = self.from_address.lower()
        return any(pattern in email_lower for pattern in noreply_patterns)
    
    def get_sort_key(self) -> int:
        """Get sorting key - now uses urgency_score if available"""
        if hasattr(self, 'urgency_score') and self.urgency_score > 0:
            return self.urgency_score
        return self.importance.value


@dataclass
class Analysis:
    """Analysis result from LLM"""
    importance: Importance
    replyability: Replyability
    action: Action
    reasoning: str
    confidence: str = "MEDIUM"
    
    @classmethod
    def create_fallback(cls, reasoning: str = "LLM analysis failed") -> 'Analysis':
        """Create a safe fallback analysis when LLM fails"""
        return cls(
            importance=Importance.NORMAL,
            replyability=Replyability.UNKNOWN,
            action=Action.READ_ONLY,
            reasoning=reasoning,
            confidence="LOW"
        )


@dataclass
class ReplyDraft:
    """Draft reply generated by LLM"""
    body: str
    subject: str
    reasoning: str
    should_reply: bool = True
    warnings: List[str] = field(default_factory=list)
    
    @classmethod
    def create_noreply(cls, original_subject: str) -> 'ReplyDraft':
        """Create a draft indicating this email shouldn't be replied to"""
        return cls(
            body="",
            subject=original_subject,
            reasoning="No-reply address detected",
            should_reply=False,
            warnings=["This is a no-reply address. Reply not recommended."]
        )


@dataclass
class EmailBatch:
    """Container for a batch of emails being processed"""
    emails: List[Email]
    fetched_at: datetime
    total_count: int
    
    def get_prioritized(self) -> List[Email]:
        """Return emails sorted by urgency score (content-based)"""
        return sorted(self.emails, key=lambda e: e.get_sort_key(), reverse=True)
    
    def get_by_action(self, action: Action) -> List[Email]:
        """Filter emails by recommended action"""
        return [e for e in self.emails if e.action == action]
    
    def get_statistics(self) -> dict:
        """Get statistics about the email batch"""
        stats = {
            'total': len(self.emails),
            'by_importance': {},
            'by_action': {},
            'replyable': 0,
            'noreply': 0
        }
        
        for email in self.emails:
            # Count by importance
            imp_name = email.importance.name
            stats['by_importance'][imp_name] = stats['by_importance'].get(imp_name, 0) + 1
            
            # Count by action
            action_name = email.action.name
            stats['by_action'][action_name] = stats['by_action'].get(action_name, 0) + 1
            
            # Count replyable
            if email.replyability == Replyability.YES:
                stats['replyable'] += 1
            
            # Count noreply addresses
            if email.is_noreply():
                stats['noreply'] += 1
        
        return stats
